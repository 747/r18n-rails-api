= R18n

R18n is a i18n tool to translate your Ruby application to several languages.

Use <tt>sinatra-r18n</tt> or teamon’s <tt>merb_i18n</tt> to localize Web applications and 
<tt>r18n-desktop</tt> to localize desktop application.

== Features

=== Ruby-style syntax
R18n uses hierarchical not English-centrist YAML format for translations by
default:

  user:
    edit: Edit user
    name: User name is %1
    count: !!pl
      1: There is 1 user
      n: There are %1 users

To access translation you can call methods with same names:

  i18n.user.edit         #=> "Edit user"
  i18n.user.name('John') #=> "User name is John"
  i18n.user.count(5)     #=> "There are 5 users"

If translation key has name of Object method you can use another way:

  i18n[:methods] #=> "Methods"

=== Filters

You can add custom filters for some YAML type or any translated strings.
Filters are cascade and can communicate with each other.

R18n already has filters for HTML
escaping, lambdas, Textile and Markdown:

  hi: !!markdown
    **Hi**, people!
  greater: !!escape
    1 < 2 is true

  i18n.hi      #=> "<p><strong>Hi</strong>, people!</p>"
  i18n.greater #=> "1 &lt; 2 is true"

=== Flexibility

Translation variables and pluralization (“1 comment”, “5 comments”) are filters
too. So you can extend or replace it. For example, you can enable built-in named
variables filter:

  greeting: Hi, {{name}}

  R18n::Filters.on(:named_variables)
  i18n.greeting(name: 'John') #=> "Hi, John"

=== Flexible locales

Locale together with YAML description can extend Locale class, so locales
are very flexible. For example, Russian locale has built-in different
pluralization without any lambdas in YAML:

  i18n.user.count(1) #=> "1 пользователь"
  i18n.user.count(2) #=> "2 пользователя"
  i18n.user.count(5) #=> "5 пользователей"

Or English locale extend time formatters:

  i18n.l Date.now, :full #=> "30th of November, 2009"

=== Loaders

R18n can load translations from any places, not just from YAML files. You just
need to create loader object with 2 methods: +available+ and +load+:

  class DBLoader
    def available
      Translation.find(:all).map(&:locale)
    end
    def load(locale)
      Translation.find(locale).to_hash
    end
  end
  
  i18n = R18n::I18n.new(user_locales, DBLoader.new)

You can also set a list of different translation places or set extension places,
which will be used only with application translation (useful for plugins).

=== Object translation

You can translate any class, including ORM models:

  require 'r18n-core/translated'
  
  class Product < ActiveRecord::Base
    include R18n::Translated
    # Model has two usual property: title_en and title_ru
    translations :title
  end
  
  # For English user
  product.title #=> "Anthrax"
  
  # For Russian user
  product.title #=> "Сибирская язва"

=== Localization

R18n can localize numbers and time:

  i18n.l -5000                 #=> "−5,000"
  i18n.l Time.now              #=> "30/11/2009 14:36"
  i18n.l Time.now, :full       #=> "30th of November, 2009 14:37"
  i18n.l Time.now - 60, :human #=> "1 minute ago"

=== Several user languages support

Lack of translation in user language isn’t exception for R18n (because
translation to not primary language done by enthusiasts, it can be out of date).
R18n just automatically take next user language (browser send a list of locales)
and for cultures with two officially languages (e.g., exUSSR) it take second
language (e.g., if translation isn’t available in Kazakh R18n will see in
Russian):

  i18n = R18n::I18n.new(['kk', 'de'], 'dir/with/translations')
  
  i18n.locales    #=> [Locale kk (Қазақша), Locale de (Deutsch),
                  #    Locale ru (Русский), Locale en (English)]
  
  i18n.kazakh  #=> "Қазақша", main user language
  i18n.deutsch #=> "Deutsch", not in Kazakh, use next user locale
  i18n.russian #=> "Русский", not in kk and de, use Kazakh sublocale
  i18n.english #=> "English", not in any user locales, use default

=== Agnostic

R18n has a agnostic core package and plugins with out-of-box support for
Sinatra, Merb and desktop applications.

== Usage

=== Translation
Translation files use YAML format and has name like en.yml (English) or
en-us.yml (USA English dialect) with language/country code (RFC 3066).

In translation you can use:
* Strings
    robot: This is robot
    percent: "Percent sign (%)"
* Numbers
    number: 123
    float: 12.45
* Pluralizable messages
    robots: !!pl
      0: No robots
      1: One robot
      n: %1 robots
* Filters
    filtered: !!custom_type
      This content will be processed by filter

To get translated string use method with key name or square brackets [] for
keys, which is same with Object methods (+class+, +inspect+, etc):

  i18n.robot    #=> "This is robot"
  i18n[:robot] #=> "This is robot"

Translation may be hierarchical:

  i18n.post.add       #=> "Add post"
  i18n[:post][:add] #=> "Add post"

If locale willn’t be found in user locale R18n will search it in they sublocales
or in another locale, which user know:

  i18n.no.in.english #=> "В английском нет"

Translated string has +locale+ method and you can get it locale (Locale instance
or code string if locale is’t supported in R18n):

  i18n.no.in.english.locale #=> Locale ru (Русский)

You can replace some parameters in translated string by put it as arguments:
  
  name: "My name is %1"

  i18n.name('John') #=> "My name is John"

You can also use named parameters by <tt>:named_variables</tt> filter (disabled
by default):

  name: "My name is {{name}}"
  
  R18n::Filters.on(:named_variables)
  i18n.name(name: 'Ivan') #=> "My name is Ivan"

Pluralizable messages get item count from first argument:

  i18n.robots(0)  #=> "No robots"
  i18n.robots(1)  #=> "One robot"
  i18n.robots(50) #=> "50 robots"

If there isn’t pluralization for some number, translation will be use 'n'. If
there isn’t locale file for translation, it will be use English pluralization
rule (0, 1 and 'n').

R18n already has translation for common words for most supported locales.
See <tt>base/</tt> in dir in gem.

  i18n.yes    #=> "Yes"
  i18n.cancel #=> "Cancel"
  i18n.delete #=> "Delete"

=== Filters
You can also add you own filter for translations: escape HTML entries, convert
from Markdown syntax, etc.

  R18n::Filters.add('custom_type', :filter_name) do |content, config, replace|
    content.gsub(' ', replace)
  end
  R18n::Filters.add('custom_type') do |content, config, replace|
    content + '!'
  end
  
  i18n.filtered('_') #=> "This_content_will_be_processed_by_filter!"

You can also add global filters for all translated strings:

  R18n::Filters.add(String, :capitalize_ruby) do |content, config|
    content.gsub(/ruby/i) { |i| i.swapcase }
  end

==== HTML Escape
R18n contain 2 filters to escape HTML entries: by YAML type and global. If you
need to escape HTML in some translations, just set <tt>!!escape</tt> YAML type:

  greater: !!escape
    1 < 2 is true

  i18n.greater #=> "1 &lt; 2 is true"

If you develop web application and want to escape HTML in all translations, just
activate global escape filter:

  R18n::Filters.on(:global_escape_html)

If you enable global HTML escape, you may use <tt>!!html</tt> YAML type to
disable escaping in some special value.

  warning: !!html
    <b>Warning</b>

  R18n::Filters.on(:global_escape_html)
  i18n.warning #=> "<b>Warning</b>"

==== Markdown
To use Markdown in your translations you must install maruku gem:

  hi: !!markdown
    **Hi**, people!

  i18n.hi #=> "<p><strong>Hi</strong>, people!</p>"


==== Textile
To use Textile in your translations you must install RedCloth gem:

  alarm: !!textile
    It will delete _all_ users!

  i18n.alarm #=> "<p>It will delete <em>all</em> users!</p>"

==== Lambdas
You can use lambdas in your translations.

  sum: !!proc |x, y| x + y

  i18n.sum(1, 2) #=> 3

If it isn’t secure in your application (for example, user can change
translations), you can disable it:

  R18n::Filters.off(:procedure)

=== Localization
You can print number and float according to the rules of the user locale:

  i18n.l -12000.5 #=> "−12,000.5"

Number and float formatters will also put real typographic minus and put
non-break thin spaces (for locale, which use it as digit separator).

You can translate months and week days names in Time, Date and DateTime by
+strftime+ method:

  i18n.l Time.now, '%B'  #=> "September"

R18n has some time formats for locales: <tt>:human</tt>, <tt>:full</tt> and
<tt>:standard</tt> (by default):

  i18n.l Time.now, :human #=> "now"
  i18n.l Time.now, :full  #=> "August 9th, 2009 21:47"
  i18n.l Time.now         #=> "08/09/2009 21:41"
  i18n.l Time.now.to_date #=> "08/09/2009"

=== Model
You can add i18n support to any classes, including ORM models:

  require 'r18n-core/translated'
  
  class Product
    include DataMapper::Resource
    property :title_ru, String
    property :title_en, String
    
    include R18n::Translated
    translations :title
  end
  
  # For example, user know only Russian
  
  # Set value to English (default) title
  product.title_en = "Anthrax"
  product.title #=> "Anthrax"
  
  # Set value to title on user locale (Russian)
  product.title = "Сибирская язва"
  product.title #=> "Сибирская язва"
  
  product.title_en #=> "Anthrax"
  product.title_ru #=> "Сибирская язва"

See R18n::Translated for documentation.

=== Locale
All supported locales are storage in R18n gem at +locales+ dir. If you want to
add your locale, please write me to andrey@sitnik.ru.

To get information about locale create R18n::Locale instance:

  locale = R18n::Locale.load('en')

You can get from locale:
* Locale title and RFC 3066 code:
  
    locale.title #=> "English"
    locale.code  #=> "en"
  
* Language direction (left to right, or right to left for Arabic and Hebrew):
  
    locale.ltr? #=> true
  
* Week start day ("sunday" or "monday"):
  
    locale['week']['start'] #=> "sunday"

=== Loaders
You can load translations from any ways, not just from YAML files. To load
translation you must create loader class with 2 methods:
* <tt>available</tt> – return array of locales of available translations;
* <tt>load(locale)</tt> – return Hash of translation.
And put it instance to <tt>R18n::I18n.new</tt>:

  R18n::I18n.new('en', MyLoader.new(loader_param))

You can set your loader as default and pass to <tt>R18n::I18n.new</tt> only
constructor argument:

  R18m.default_loader = MyLoader
  R18n::I18n.new('en', loader_param)

=== Extension translations
For r18n plugin you can add loaders with translations, which will be used with
application translations. For example, DB plugin may place translations for
error messages in extension dir. R18n contain translations for base words as
extension dir too.

  R18n.extension_places << R18n::Loader::YAML.new('./error_messages/')

== Add locale
If R18n hasn’t locale file for your language, please add it. It’s very simple:
* Create in locales/ file _code_.yml for your language and describe locale.
  Just copy from another locale and change different values.
  * If your language is dialect or base on another (as American English (en-US) 
    base on English (en)) write <tt>include: _base_locale_</tt> and similar
    values can be deleted.
  * If in your country people mostly know another language (like in exUSSR
    countries people know Russian), write
    <tt>sublocales: [_another_locale_, en]</tt>. Else write only:
    <tt>sublocales: [en]</tt>. For dialect put base locale to +sublocales+ too.
* Create in base/ file _code_.yml for your language and translate base messages.
  Just copy file from language, which you know, and rewrite values.
* If you language need some special logic (for example, different pluralization
  or time formatters) you can change Locale class. Create in locales/ file
  _code_.rb and write R18n::Locales::_Code_ class, which must extend
  R18n::Locale.
* Push files by GitHub (http://github.com/ai/r18n) or just write e-mail with
  this files to me (andrey@sitnik.ru).

_Code_ is RFC 3066 code for your language (for example, “en” for English and
“fr_CA” for Canadian French). You can send to my e-mail any questions (on
http://sitnik.ru you find another contact addresses).

== License
R18n is licensed under the GNU Lesser General Public License version 3.
You can read it in LICENSE file or in http://www.gnu.org/licenses/lgpl.html.

== Author
Andrey “A.I.” Sitnik <andrey@sitnik.ru>
